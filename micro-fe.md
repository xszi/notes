## 微前端架构

基于spa的微前端架构

### 前端架构的发展历程

原始（js作为后端内容的辅助部分）——> MVC ——> Node.js赋能前端打包构建 ——> 前后端分离 ——> 多个关联应用分离开发（多页面） ——> 使用微前端架构进行聚合

### 软件设计原则（SOLID六大原则）

* 单一职责原则
* 开放封闭原则：对扩展开发，对修改封闭
* 里氏替换原则：父类一定能够被子类替换
* 最小知识原则：高内聚，低耦合
* 接口隔离原则：不向外暴露没有实际意义的接口
* 依赖倒置原则：应该面向接口编程（有接口），而不是面向类编程

    其他原则：

    * 组合/聚合复用原则：优先考虑使用组合，而不是继承
    * 无环依赖原则
    * 共同封装原则
    * 共同重用原则（减少包）
    * 好莱坞原则：控制反转
    * 不要重复你自己
    * 保持它简单与傻瓜
    * 高内聚，低耦合
    * 关注点分离
    * 你不需要它（不要过度设计）

BFF是什么？

巨石应用 ——> 细粒度，微应用

### 架构设计质量

* 系统的稳定性
* 系统的健壮性

    衡量标准：

    * 拓展性
    * 维护性
    * 可管理
    * 高可用切换（故障修复，容灾，降级，熔断）
    * 理解难度
    * 崩溃率和错误率指标
    * 开发效率
    * 错误上报和信息收集

### 技术债务填补和崩溃预防

等产品上线后，业务便没有这么紧张，这个时候大家可以找个时间处理技术债务，一边建立感情，一边品味一下原来的代码，这种感觉及其酸爽。

* 对脏数据进行兜底和检验
* 单元测试
* 崩溃报警
* 自动化测试
* 更广的灰度触达
* 性能优化体系

### 什么是重构？

* 对软件内部整体结构的一种调整。
* 运用大量微小且保持软件行为的步骤，一步步达到大规模的修改。

重构种类：
    * 系统级架构
    * 应用级架构
    * 模块级架构
    * 代码级架构

#### 微重构：

确定重构功能和范围 ——> 旧架构设计和逻辑梳理 ——> 稳定性保证 ——> 性能保证 ——> 需求过程中的冲突问题

### 微前端实现方式对比

#### Iframe

优势：
* 技术成熟
* 支持页面嵌入
* 天然支持运行沙箱隔离，独立运行

劣势：
* 页面之间可以是不同的域名
* 需要对应的设计一套应用通讯机制，如何监听，传参格式等内容
* 应用加载，渲染，缓存等体系的实现

#### web component（H5）

优势：
* 支持自定义元素
* 支持shadow dom， 可以通过关联进行控制
* 支持模块template和插槽slot，引入自定义组件内容
劣势：
* 接入微前端需要重写当前项目
* 生态系统不完善，技术过新容易出现兼容行问题
* 整体架构设计复杂，组件与组件之间拆分过细时，容易造成通讯和控制繁琐

#### 自研框架spa

优势：
* 高度定制化，满足需要做兼容的一切场景
* 独立的通信机制和沙箱运行机制，可解决应用之间相互影响的问题
* 支持不同技术栈子应用，可无缝实现页面无刷新渲染
劣势：
* 技术实现难度较高
* 需要设计一套定制的通信机制
* 首次加载会出现资源过大的情况

#### 自研框架实现

* 路由分发式
* 主应用控制路由匹配和子应用加载，共享依赖加载
* 子应用做功能，并接入主应用实现主子控制和联动

#### 技术选型

* 主应用（vue3）
* 子应用（vue2/vue3/react15/react16）
* 后端服务和发布应用
* 服务端接口（koa）
* 发布应用（node/express）

#### 绘制项目架构图

分析需求：

1. 主应用
    * 注册子应用
    * 加载、渲染子应用
    * 路由匹配 （activeWhen， rules - 由框架判断）
    * 获取数据（公共依赖，通过数据做鉴权处理）
    * 通信（父子通信，子父通信）

2. 子应用的功能
    * 渲染
    * 监听通信（主应用传递过来的数据）

3. 微前端框架
    * 子应用的注册
    * 应用开始，应用加载完成
    * 路由更新判断
    * 匹配对应的子应用
    * 加载子应用的内容
    * 完成所有依赖项的执行
    * 将子应用渲染在固定的容器内
    * 公共事件的管理
    * 异常捕获和报错
    * 全局的状态管理
    * 沙箱的隔离
    * 通信机制

4. 服务端的功能
    * 提供数据服务

5. 发布平台
    * 主子应用的发布和打包